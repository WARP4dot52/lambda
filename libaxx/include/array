#ifndef LIBAXX_ARRAY
#define LIBAXX_ARRAY

#include <stddef.h>

namespace std {

template <class T, size_t N>
constexpr size_t size(const T (&array)[N]) noexcept {
  return N;
}

// template <typename U, unsigned int N> class array;

// template <unsigned int K, typename U, unsigned int N> U get(array<U, N>
// array);

template <typename U, unsigned int N>
class array {
  // friend U get(array);
 public:
  using iterator = U*;
  using const_iterator = const U*;

  /* implicitly declared list-initialization constructor:
   * "array(initializer_list<U>)" */

  /* implicitly declared assignment operator to another array, that overwrites
   * all the array elements with the element in the other array:
   * "operator=(const array<U,N>&)" */

  constexpr U& operator[](unsigned int n) { return m_array[n]; }
  constexpr const U& operator[](unsigned int n) const { return m_array[n]; }

  constexpr const_iterator cbegin() const { return m_array; }
  constexpr const_iterator cend() const { return m_array + N; }
  constexpr iterator begin() { return m_array; }
  constexpr iterator end() { return m_array + N; }

  constexpr unsigned int size() const { return N; }

  /* m_array must be public for "array" to be an aggregate type, and thus
   * benefit from the advantages of aggregates, in particular the implicit
   * list-initialization constructor.
   */
  U m_array[N];
};
/*
template <unsigned int K, typename U, unsigned int N>
U get(array<U, N> array) {
  static_assert(K<N, "out-of-bound access");
  return array.m_array[K];
}
*/
}  // namespace std

#endif
